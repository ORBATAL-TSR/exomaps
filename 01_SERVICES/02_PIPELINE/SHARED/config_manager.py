"""
Unified Environment Configuration Management

Provides a single source of truth for configuration that:
1. Auto-detects available services (PostgreSQL, Redis)
2. Loads environment files in proper order (.env.auto > .env > defaults)
3. Validates required settings
4. Falls back gracefully when services are unavailable
"""

import os
import sys
from pathlib import Path
from typing import Dict, Optional


class ConfigManager:
    """
    Unified configuration with auto-detection and validation.
    
    Priority (highest to lowest):
    1. Environment variables (already set)
    2. .env.auto (auto-detected by health_check.sh)
    3. .env (manual configuration)
    4. Built-in defaults
    """
    
    # Default values
    DEFAULTS = {
        "POSTGRES_USER": "postgres",
        "POSTGRES_PASSWORD": "",
        "POSTGRES_DB": "exomaps",
        "POSTGRES_HOST": "127.0.0.1",
        "POSTGRES_PORT": "5432",
        "APPUSER": "appuser",
        "APPPASS": "",
        "REDIS_HOST": "127.0.0.1",
        "REDIS_PORT": "6379",
        "FLASK_HOST": "127.0.0.1",
        "FLASK_PORT": "5000",
    }
    
    def __init__(self, root_dir: Optional[str] = None, autodetect=True):
        """
        Initialize configuration manager.
        
        Args:
            root_dir: Project root directory (auto-detected if None)
            autodetect: Use service discovery to detect available services
        """
        self.root_dir = Path(root_dir or os.getcwd())
        self.config: Dict[str, str] = {}
        
        # Load configuration in priority order
        self._load_builtin_defaults()
        self._load_env_files()
        self._load_environment_variables()
        
        # Try service discovery if available
        if autodetect:
            try:
                self._apply_service_discovery()
            except Exception as e:
                # Service discovery is optional
                pass
    
    def _load_builtin_defaults(self):
        """Load built-in default values."""
        self.config.update(self.DEFAULTS)
    
    def _load_env_files(self):
        """Load configuration from .env files."""
        # Try .env.auto first (auto-generated by health_check.sh)
        auto_env = self.root_dir / ".env.auto"
        if auto_env.exists():
            self._load_env_file(auto_env, label="auto-detected")
        
        # Try .env second (manual configuration)
        manual_env = self.root_dir / ".env"
        if manual_env.exists():
            self._load_env_file(manual_env, label="manual .env")
    
    def _load_env_file(self, filepath: Path, label="unknown"):
        """Load individual .env file."""
        try:
            with open(filepath, 'r') as f:
                for line in f:
                    line = line.strip()
                    
                    # Skip comments and empty lines
                    if not line or line.startswith('#'):
                        continue
                    
                    # Parse KEY=VALUE
                    if '=' in line:
                        key, value = line.split('=', 1)
                        key = key.strip()
                        value = value.strip()
                        
                        # Remove quotes if present
                        if value.startswith('"') and value.endswith('"'):
                            value = value[1:-1]
                        elif value.startswith("'") and value.endswith("'"):
                            value = value[1:-1]
                        
                        self.config[key] = value
        except Exception as e:
            print(f"Warning: Failed to load {label} from {filepath}: {e}", file=sys.stderr)
    
    def _load_environment_variables(self):
        """Override with any already-set environment variables."""
        for key in self.DEFAULTS.keys():
            if key in os.environ:
                self.config[key] = os.environ[key]
    
    def _apply_service_discovery(self):
        """Use service discovery to auto-detect available services."""
        try:
            from dbs.service_discovery import ServiceDiscovery
            sd = ServiceDiscovery(verbose=False)
            
            # Get auto-detected hosts
            db = sd.services.get("postgres")
            if db and db.is_available():
                self.config["POSTGRES_HOST"] = db.host
            
            redis = sd.services.get("redis")
            if redis and redis.is_available():
                self.config["REDIS_HOST"] = redis.host
        except ImportError:
            # Service discovery module not available
            pass
    
    def get(self, key: str, default: Optional[str] = None) -> str:
        """
        Get configuration value with optional default.
        
        Args:
            key: Configuration key name
            default: Default value if not found
        
        Returns:
            Configuration value or default
        """
        return self.config.get(key, default or self.DEFAULTS.get(key, ""))
    
    def get_dict(self, *keys) -> Dict[str, str]:
        """Get multiple configuration values as dictionary."""
        if not keys:
            return dict(self.config)
        
        return {key: self.get(key) for key in keys}
    
    def get_db_url(self) -> str:
        """
        Get PostgreSQL connection URL.
        
        Supports:
        - TCP: postgresql://user:password@host:port/database
        - Unix socket: postgresql://user:password@/database?host=/path/to/socket
        """
        user = self.get("POSTGRES_USER")
        password = self.get("POSTGRES_PASSWORD")
        host = self.get("POSTGRES_HOST")
        port = self.get("POSTGRES_PORT")
        db = self.get("POSTGRES_DB")
        
        # Check if host is a Unix socket path (starts with /)
        if host.startswith('/'):
            # Unix socket connection
            # Format: postgresql://user[:password]@/database?host=/path/to/socket
            if password:
                return f"postgresql://{user}:{password}@/{db}?host={host}"
            else:
                return f"postgresql://{user}@/{db}?host={host}"
        else:
            # TCP connection
            return f"postgresql://{user}:{password}@{host}:{port}/{db}"
    
    def get_redis_url(self) -> Optional[str]:
        """
        Get Redis connection URL if configured.
        
        Format: redis://host:port/0
        """
        host = self.get("REDIS_HOST", "")
        port = self.get("REDIS_PORT", "6379")
        
        if host:
            return f"redis://{host}:{port}/0"
        return None
    
    def validate(self) -> bool:
        """Validate required configuration is set."""
        required = ["POSTGRES_USER", "POSTGRES_PASSWORD", "POSTGRES_DB"]
        
        for key in required:
            if not self.get(key):
                print(f"Error: Required config {key} not set", file=sys.stderr)
                return False
        
        return True
    
    def print_summary(self):
        """Print configuration summary (with password masked)."""
        print("\n" + "=" * 60)
        print("CONFIGURATION SUMMARY")
        print("=" * 60)
        for key in sorted(self.config.keys()):
            value = self.config[key]
            # Mask passwords
            if "PASS" in key:
                display_value = "***"
            else:
                display_value = value
            print(f"{key:20} = {display_value}")
        print("=" * 60)


# Global instance
_config_manager: Optional[ConfigManager] = None


def get_config() -> ConfigManager:
    """Get global configuration manager instance."""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager()
    return _config_manager


def reset_config():
    """Reset global configuration (for testing)."""
    global _config_manager
    _config_manager = None


if __name__ == "__main__":
    # Print configuration
    config = get_config()
    config.print_summary()
    
    # Validate
    if config.validate():
        print("\n✓ Configuration is valid")
        print(f"\nPostgreSQL URL: {config.get_db_url().replace(config.get('POSTGRES_PASSWORD'), '***')}")
    else:
        print("\n✗ Configuration validation failed")
        sys.exit(1)
